/*
 * Copyright 2021 Allette Systems (Australia)
 * http://www.allette.com.au
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.pageseeder.ox.cleanup;

import org.eclipse.jdt.annotation.NonNull;
import org.eclipse.jdt.annotation.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Clean the files generated by this application.
 *
 * @author Carlos Cabral
 * @since  25 October 2018
 */
public class CleanUpManager {

  /**  the logger. */
  private static final Logger LOGGER = LoggerFactory.getLogger(CleanUpManager.class);

  /**  Check every 2 minutes. */
  public static final long DEFAULT_DELAY = 2 * 60 * 1000;

  /** Singleton Instance of this class. */
  private static volatile CleanUpManager INSTANCE;

  /**  a thread executor. */
  private ExecutorService threadPool = null;

  /**shows that this thread has been started. */
  private volatile AtomicBoolean started;

  /** Shows that this thread has been requested to stop. */
  private volatile AtomicBoolean stopped;

  /** The clean up job. */
  private final CleanUpJob cleanUpJob;

  /**
   * Instantiates a new clean up manager.
   *
   * @param maxInactiveTime How long (milliseconds) a file can be inactive in the drive.
   * @param delay the delay between check up.
   * @param base The packages root directory.
   */
  private CleanUpManager(long maxInactiveTime, long delay, File base) {
    //Started the thread pool
    this.threadPool = Executors.newSingleThreadExecutor();
    this.started = new AtomicBoolean(false);
    this.stopped = new AtomicBoolean(false);


    long tempDelay = delay > 0 ? delay : DEFAULT_DELAY;

    //Instantiate job class
    this.cleanUpJob = new CleanUpJob(maxInactiveTime, tempDelay, base);
  }

  /**
   * Returns .
   *
   * @param maxInactiveTime How long (milliseconds) a file can be inactive in the drive.
   * @param delay the delay between check up.
   * @param base The packages root directory.
   * @return single instance of CleanUpManager
   */
  public static synchronized @NonNull CleanUpManager getInstance(long maxInactiveTime, long delay, File base) {
    if (INSTANCE == null) {
      INSTANCE = new CleanUpManager(maxInactiveTime, delay, base);
    }
    return INSTANCE;
  }

  /**
   * Returns .
   *
   * @return single instance of CleanUpManager
   */
  public static synchronized @Nullable CleanUpManager getInstance() {
    return INSTANCE != null ? INSTANCE : null;
  }


  /**
   * Add a job to process.
   */
  public void start() {
    //If not started
    if (!this.started.getAndSet(true)) {
      //Execute Clean up job
      LOGGER.debug("Execute Clean UP JOB");
      this.threadPool.execute(this.cleanUpJob);
    }
  }

  /**
   * Stop.
   */
  public void stop() {
    if (!this.stopped.getAndSet(true)) {
      LOGGER.debug("Stopping Clean UP Manager.");
      this.cleanUpJob.stop();

      try {
        this.threadPool.shutdown();
        LOGGER.debug("First attempt to stopping Clean UP");
        this.threadPool.awaitTermination(5, TimeUnit.SECONDS);
      } catch (InterruptedException ex) {
        LOGGER.debug("Unable to stope Thread Pool in less than 10 seconds.");
      } finally {
        LOGGER.debug("Clean UP Manager Stopped.");
        this.threadPool.shutdownNow();
        //Destroy Singleton instance
        INSTANCE = null;
      }
    }
  }

  /**
   * Add file to be ignored and then they will not be deleted.
   * @param toIgnore
   */
  public void addFileToIgnore(File toIgnore){
    this.cleanUpJob.addFileToIgnore(toIgnore);
  }

  /**
   * remove file that is supposed to be ignored.
   * @param toIgnore
   */
  public void removeFileToIgnore(File toIgnore) {
    this.cleanUpJob.removeFileToIgnore(toIgnore);
  }

  /**
   * Return job status.
   *
   * @return the status
   */
  public CleanUpStatus status () {
    return this.cleanUpJob.getStatus();
  }
}
